<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MECH-COMMAND: ANUBIS DIGITAL</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #000; 
            overflow: hidden; 
            font-family: 'Segoe UI', 'Courier New', monospace;
            color: #00ff9d;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* Landscape Guard */
        #landscape-guard {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #00ff9d;
            text-align: center;
            padding: 20px;
            display: none;
        }
        #landscape-guard.visible { display: flex; }
        #landscape-guard h1 { 
            font-size: 2rem; 
            margin-bottom: 1rem;
            text-shadow: 0 0 20px #00ff9d;
        }
        #landscape-guard p { 
            font-size: 1rem; 
            opacity: 0.8; 
            max-width: 300px;
        }
        .rotate-icon {
            font-size: 3rem;
            margin-bottom: 2rem;
            animation: rotate 2s infinite linear;
        }
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(90deg); }
        }

        /* Main Canvas */
        #game-canvas { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
        }

        /* Combat Log HUD */
        #combat-log {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 250px;
            max-height: 150px;
            overflow-y: auto;
            font-size: 11px;
            z-index: 50;
            pointer-events: none;
            background: rgba(0, 20, 10, 0.7);
            border-left: 2px solid #00ff9d;
            padding: 10px;
            backdrop-filter: blur(5px);
        }
        .log-entry {
            color: #00ff9d;
            margin-bottom: 5px;
            opacity: 0.9;
            animation: fadeIn 0.3s ease;
            text-shadow: 0 0 5px #00ff9d;
        }
        .log-entry.system { color: #00ccff; }
        .log-entry.damage { color: #ff3300; }
        .log-entry.alert { color: #ffff00; }
        .log-entry.success { color: #00ff9d; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 0.9; transform: translateX(0); }
        }

        /* Health Bars */
        #health-container {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 50;
        }
        .health-bar {
            width: 200px;
            height: 12px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ff9d;
            border-radius: 2px;
            margin-bottom: 8px;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 255, 157, 0.3);
        }
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff9d, #00cc66);
            width: 100%;
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .health-label {
            color: #00ff9d;
            font-size: 10px;
            margin-bottom: 3px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        /* Control Interface */
        #controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 50;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .control-row {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        /* Mobile Controls */
        .control-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(0, 255, 157, 0.15);
            border: 2px solid #00ff9d;
            color: #00ff9d;
            font-size: 11px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            transition: all 0.1s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 255, 157, 0.2);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .control-btn:active {
            background: rgba(0, 255, 157, 0.3);
            transform: scale(0.95);
            box-shadow: 0 0 30px rgba(0, 255, 157, 0.4);
        }
        .control-btn.combat {
            background: rgba(255, 51, 0, 0.15);
            border-color: #ff3300;
            color: #ff3300;
        }
        .control-btn.combat:active {
            background: rgba(255, 51, 0, 0.3);
        }
        .control-btn.spawn {
            background: rgba(0, 204, 255, 0.15);
            border-color: #00ccff;
            color: #00ccff;
        }
        .control-btn.spawn:active {
            background: rgba(0, 204, 255, 0.3);
        }

        /* Performance Stats */
        #stats {
            position: absolute;
            bottom: 100px;
            right: 15px;
            color: #00ff9d;
            font-size: 9px;
            opacity: 0.5;
            z-index: 50;
        }

        /* Combat Effects */
        .hit-effect {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background: radial-gradient(circle at center, transparent 30%, rgba(255, 0, 0, 0.3) 70%);
            opacity: 0;
            pointer-events: none;
            z-index: 25;
        }
        .hit-effect.active {
            animation: hitFlash 0.3s ease;
        }
        @keyframes hitFlash {
            0% { opacity: 0; }
            50% { opacity: 0.7; }
            100% { opacity: 0; }
        }

        /* Enemy Counter */
        #enemy-counter {
            position: absolute;
            top: 50px;
            right: 15px;
            color: #00ff9d;
            font-size: 11px;
            z-index: 50;
        }

        /* Enemy Types */
        .enemy-types {
            position: absolute;
            top: 100px;
            left: 15px;
            z-index: 50;
            display: flex;
            gap: 5px;
        }
        .enemy-type-btn {
            background: rgba(255, 51, 0, 0.1);
            border: 1px solid #ff3300;
            color: #ff3300;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
        }
        .enemy-type-btn:active {
            background: rgba(255, 51, 0, 0.3);
        }
    </style>
</head>
<body>
    <!-- Landscape Orientation Guard -->
    <div id="landscape-guard">
        <div class="rotate-icon">↻</div>
        <h1>ROTATE TO LANDSCAPE</h1>
        <p>For optimal combat experience, please rotate your device to landscape mode.
        <br>  Just know Anubis digital is not interested in gaming he's just trying his abilities</p>
    </div>

    <!-- Combat Log -->
    <div id="combat-log"></div>

    <!-- Health Bars -->
    <div id="health-container">
        <div class="health-label">OPERATOR INTEGRITY</div>
        <div class="health-bar">
            <div id="player-health" class="health-fill" style="width: 100%"></div>
        </div>
        <div class="health-label" id="enemy-label" style="display: none">TARGET INTEGRITY</div>
        <div class="health-bar" id="enemy-health-bar" style="display: none">
            <div id="enemy-health" class="health-fill" style="width: 100%"></div>
        </div>
    </div>

    <!-- Enemy Counter -->
    <div id="enemy-counter">TARGETS: 0</div>

    <!-- Performance Stats -->
    <div id="stats"></div>

    <!-- Combat Effects -->
    <div class="hit-effect" id="hit-effect"></div>

    <!-- Canvas -->
    <canvas id="game-canvas"></canvas>

    <!-- Controls -->
    <div id="controls">
        <!-- Movement Controls (Left Side) -->
        <div class="control-group">
            <div class="control-row">
                <button class="control-btn" onpointerdown="startMove('Walk')" onpointerup="stopMove()">WALK</button>
                <button class="control-btn" onpointerdown="startMove('Run')" onpointerup="stopMove()">RUN</button>
            </div>
            <div class="control-row">
                <button class="control-btn" onpointerdown="startTurn('Left')" onpointerup="stopTurn()">↶ LEFT</button>
                <button class="control-btn" onpointerdown="startTurn('Right')" onpointerup="stopTurn()">↷ RIGHT</button>
            </div>
        </div>

        <!-- Combat Controls (Right Side) -->
        <div class="control-group">
            <div class="control-row">
                <button class="control-btn spawn" onclick="spawnEnemy()">SPAWN ENEMY</button>
            </div>
            <div class="control-row">
                <button class="control-btn combat" onclick="playerAttack('Punch')">PUNCH</button>
                <button class="control-btn combat" onclick="playerAttack('Dagger_Attack')">STRIKE</button>
                <button class="control-btn" onclick="evade()">EVADE</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // GAME ENGINE CONFIGURATION
        // ============================================
        const CONFIG = {
            PLAYER: {
                HEALTH: 100,
                MOVE_SPEED: { WALK: 0.05, RUN: 0.12 },
                TURN_SPEED: 0.02,
                ATTACK_DAMAGE: { PUNCH: 15, DAGGER: 20 },
                ATTACK_RANGE: 2.5,
                ATTACK_COOLDOWN: 800
            },
            ENEMY: {
                HEALTH: 60,
                DAMAGE: 12,
                SPEED: 0.04,
                CHASE_RANGE: 20,
                STATES: {
                    IDLE: 'idle',
                    CHASE: 'chase',
                    ATTACK: 'attack',
                    EVADE: 'evade',
                    DEAD: 'dead'
                },
                ATTACK_COOLDOWN: 1500,
                EVADE_CHANCE: 0.3
            },
            WORLD: {
                TILE_SIZE: 50,
                TILE_COUNT: 3,
                FAR_CLIP: 1000
            },
            VISUAL: {
                GRID_COLOR: 0x00ff9d,
                GRID_SIZE: 50,
                AMBIENT_LIGHT: 0x404040,
                DIRECTIONAL_LIGHT: 0x00ff9d
            }
        };

        // ============================================
        // GLOBAL STATE
        // ============================================
        let scene, camera, renderer, clock;
        let player = {
            object: null,
            mixer: null,
            actions: {},
            health: CONFIG.PLAYER.HEALTH,
            moveSpeed: 0,
            turnSpeed: 0,
            lastAttack: 0,
            currentTile: { x: 0, z: 0 }
        };
        let enemies = [];
        let floorTiles = [];
        let infiniteWorldEnabled = true;
        let enemyCounter = 0;

        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            // Initialize Three.js core
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x001a0d, 50, 200);
            clock = new THREE.Clock();

            // Camera setup
            camera = new THREE.PerspectiveCamera(
                45,
                window.innerWidth / window.innerHeight,
                0.1,
                CONFIG.WORLD.FAR_CLIP
            );
            camera.position.set(0, 8, 15);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('game-canvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;

            // Lighting
            const ambientLight = new THREE.AmbientLight(CONFIG.VISUAL.AMBIENT_LIGHT, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(CONFIG.VISUAL.DIRECTIONAL_LIGHT, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Create infinite floor
            createInfiniteFloor();

            // Load player character
            loadCharacter(true);

            // Start animation loop
            animate();

            // Setup event listeners
            setupEventListeners();

            // Log system startup
            addCombatLog("SYSTEM: Game initialized", "system");
            addCombatLog("SYSTEM: Infinite grid active", "system");
        }

        // ============================================
        // INFINITE FLOOR SYSTEM
        // ============================================
        function createInfiniteFloor() {
            const tileSize = CONFIG.WORLD.TILE_SIZE;
            const tileCount = CONFIG.WORLD.TILE_COUNT;
            const halfCount = Math.floor(tileCount / 2);

            for (let x = -halfCount; x <= halfCount; x++) {
                for (let z = -halfCount; z <= halfCount; z++) {
                    const tile = createFloorTile(x * tileSize, z * tileSize);
                    floorTiles.push(tile);
                }
            }
        }

        function createFloorTile(x, z) {
            // Grid helper
            const grid = new THREE.GridHelper(
                CONFIG.WORLD.TILE_SIZE,
                CONFIG.WORLD.GRID_SIZE / 2,
                CONFIG.VISUAL.GRID_COLOR,
                0x111111
            );
            grid.position.set(x, -0.1, z);
            scene.add(grid);

            // Ground plane
            const geometry = new THREE.PlaneGeometry(
                CONFIG.WORLD.TILE_SIZE,
                CONFIG.WORLD.TILE_SIZE
            );
            const material = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 0.9,
                metalness: 0.1
            });
            const plane = new THREE.Mesh(geometry, material);
            plane.rotation.x = -Math.PI / 2;
            plane.position.set(x, -0.2, z);
            plane.receiveShadow = true;
            scene.add(plane);

            return { grid, plane, x, z };
        }

        function updateInfiniteFloor() {
            if (!player.object || !infiniteWorldEnabled) return;

            const tileSize = CONFIG.WORLD.TILE_SIZE;
            const playerPos = player.object.position;
            const currentTileX = Math.round(playerPos.x / tileSize);
            const currentTileZ = Math.round(playerPos.z / tileSize);

            // Check if player moved to new tile
            if (currentTileX !== player.currentTile.x || currentTileZ !== player.currentTile.z) {
                player.currentTile = { x: currentTileX, z: currentTileZ };
                
                // Reposition tiles around player
                const halfCount = Math.floor(CONFIG.WORLD.TILE_COUNT / 2);
                
                floorTiles.forEach((tile, index) => {
                    const targetX = (currentTileX * tileSize) + 
                        ((index % CONFIG.WORLD.TILE_COUNT) - halfCount) * tileSize;
                    const targetZ = (currentTileZ * tileSize) + 
                        (Math.floor(index / CONFIG.WORLD.TILE_COUNT) - halfCount) * tileSize;
                    
                    tile.grid.position.set(targetX, -0.1, targetZ);
                    tile.plane.position.set(targetX, -0.2, targetZ);
                    tile.x = targetX;
                    tile.z = targetZ;
                });
            }
        }

        // ============================================
        // CHARACTER SYSTEM
        // ============================================
        function loadCharacter(isPlayer = true) {
            const loader = new THREE.GLTFLoader();
            loader.load('Character Animated.glb', (gltf) => {
                const character = gltf.scene;
                
                // Scale character
                const box = new THREE.Box3().setFromObject(character);
                const size = box.getSize(new THREE.Vector3());
                const scale = 4 / size.y;
                character.scale.set(scale, scale, scale);
                
                // Enable shadows
                character.traverse((node) => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                        
                        // Color the enemy differently
                        if (!isPlayer && node.material) {
                            // Clone material to avoid affecting other instances
                            node.material = node.material.clone();
                            // Enemy gets red/orange tint
                            node.material.color.set(0xff5555);
                            // Make enemy slightly emissive for visibility
                            node.material.emissive = new THREE.Color(0x331111);
                        }
                    }
                });
                
                // Setup animation mixer
                const mixer = new THREE.AnimationMixer(character);
                const actions = {};
                gltf.animations.forEach((clip) => {
                    const action = mixer.clipAction(clip);
                    actions[clip.name] = action;
                    action.clampWhenFinished = true;
                });

                if (isPlayer) {
                    // Set as player
                    player.object = character;
                    player.mixer = mixer;
                    player.actions = actions;
                    scene.add(character);
                    
                    // Start with idle animation
                    playPlayerAnimation('Idle');
                    addCombatLog("SYSTEM: Operator systems online", "system");
                } else {
                    // Return enemy data
                    return { character, mixer, actions };
                }
            });
        }

        function playPlayerAnimation(name, fadeTime = 0.2) {
            const action = player.actions[name];
            if (!action) return;

            // Get current action
            const currentAction = Object.values(player.actions).find(a => a.isRunning());
            
            if (currentAction !== action) {
                if (currentAction) {
                    currentAction.fadeOut(fadeTime);
                }
                action.reset().fadeIn(fadeTime).play();
            }
        }

        // ============================================
        // ENEMY AI STATE MACHINE
        // ============================================
        class EnemyAI {
            constructor(object, mixer, actions) {
                this.object = object;
                this.mixer = mixer;
                this.actions = actions;
                
                this.state = CONFIG.ENEMY.STATES.IDLE;
                this.health = CONFIG.ENEMY.HEALTH;
                this.maxHealth = CONFIG.ENEMY.HEALTH;
                this.target = player.object;
                this.lastAttack = 0;
                this.evadeCooldown = 0;
                this.id = ++enemyCounter;
                
                // State machine behaviors
                this.behaviors = {
                    [CONFIG.ENEMY.STATES.IDLE]: this.idleBehavior.bind(this),
                    [CONFIG.ENEMY.STATES.CHASE]: this.chaseBehavior.bind(this),
                    [CONFIG.ENEMY.STATES.ATTACK]: this.attackBehavior.bind(this),
                    [CONFIG.ENEMY.STATES.EVADE]: this.evadeBehavior.bind(this),
                    [CONFIG.ENEMY.STATES.DEAD]: this.deadBehavior.bind(this)
                };
                
                // Start with idle animation
                this.playAnimation('Idle');
            }

            playAnimation(name, fadeTime = 0.2) {
                const action = this.actions[name];
                if (!action) return;

                const currentAction = Object.values(this.actions).find(a => a.isRunning());
                
                if (currentAction !== action) {
                    if (currentAction) {
                        currentAction.fadeOut(fadeTime);
                    }
                    action.reset().fadeIn(fadeTime).play();
                }
            }

            update(delta) {
                if (this.state === CONFIG.ENEMY.STATES.DEAD) return;
                
                // Update mixer
                if (this.mixer) this.mixer.update(delta);
                
                // Update cooldowns
                if (this.evadeCooldown > 0) {
                    this.evadeCooldown -= delta * 1000;
                }
                
                // Calculate distance to player
                const distance = this.object.position.distanceTo(this.target.position);
                
                // State transitions
                if (this.health <= 0) {
                    this.setState(CONFIG.ENEMY.STATES.DEAD);
                } else if (this.state === CONFIG.ENEMY.STATES.EVADE && this.evadeCooldown <= 0) {
                    this.setState(CONFIG.ENEMY.STATES.CHASE);
                } else if (distance <= CONFIG.PLAYER.ATTACK_RANGE) {
                    this.setState(CONFIG.ENEMY.STATES.ATTACK);
                } else if (distance <= CONFIG.ENEMY.CHASE_RANGE) {
                    this.setState(CONFIG.ENEMY.STATES.CHASE);
                } else {
                    this.setState(CONFIG.ENEMY.STATES.IDLE);
                }
                
                // Execute current state behavior
                this.behaviors[this.state](delta, distance);
            }

            setState(newState) {
                if (this.state === newState) return;
                
                const oldState = this.state;
                this.state = newState;
                
                // State transition effects
                switch(newState) {
                    case CONFIG.ENEMY.STATES.CHASE:
                        addCombatLog(`ENEMY: Target ${this.id} pursuing operator`, "alert");
                        this.playAnimation('Run');
                        break;
                    case CONFIG.ENEMY.STATES.ATTACK:
                        addCombatLog(`ENEMY: Target ${this.id} engaging`, "alert");
                        break;
                    case CONFIG.ENEMY.STATES.EVADE:
                        addCombatLog(`ENEMY: Target ${this.id} evading`, "system");
                        this.evadeCooldown = 2000;
                        this.playAnimation('Roll');
                        break;
                }
            }

            idleBehavior(delta) {
                // Already playing idle animation
            }

            chaseBehavior(delta, distance) {
                // Move toward player
                const direction = new THREE.Vector3()
                    .subVectors(this.target.position, this.object.position)
                    .normalize();
                
                this.object.position.add(direction.multiplyScalar(CONFIG.ENEMY.SPEED));
                this.object.lookAt(this.target.position);
            }

            attackBehavior(delta, distance) {
                // Face player
                this.object.lookAt(this.target.position);
                
                // Attack if cooldown expired
                const now = Date.now();
                if (now - this.lastAttack > CONFIG.ENEMY.ATTACK_COOLDOWN) {
                    this.executeAttack();
                    this.lastAttack = now;
                }
            }

            executeAttack() {
                // Randomly choose attack type
                const attacks = ['Punch', 'Dagger_Attack', 'Dagger_Attack2'];
                const attackType = attacks[Math.floor(Math.random() * attacks.length)];
                
                this.playAnimation(attackType);
                
                // Check if attack hits
                setTimeout(() => {
                    const distance = this.object.position.distanceTo(player.object.position);
                    if (distance <= CONFIG.PLAYER.ATTACK_RANGE) {
                        player.health -= CONFIG.ENEMY.DAMAGE;
                        player.health = Math.max(0, player.health);
                        
                        // Update health bar
                        updateHealthBar('player-health', player.health, CONFIG.PLAYER.HEALTH);
                        
                        // Visual feedback
                        showHitEffect();
                        addCombatLog(`COMBAT: Target ${this.id} hit operator (-${CONFIG.ENEMY.DAMAGE} HP)`, "damage");
                        
                        if (player.health <= 0) {
                            gameOver();
                        }
                    }
                }, 300);
            }

            evadeBehavior(delta) {
                // Move away from player
                const direction = new THREE.Vector3()
                    .subVectors(this.object.position, this.target.position)
                    .normalize();
                
                this.object.position.add(direction.multiplyScalar(CONFIG.ENEMY.SPEED * 1.5));
            }

            deadBehavior() {
                // Play death animation
                this.playAnimation('Death');
                
                // Fade out and remove
                setTimeout(() => {
                    const index = enemies.findIndex(e => e.ai === this);
                    if (index > -1) {
                        scene.remove(this.object);
                        enemies.splice(index, 1);
                        updateEnemyCounter();
                        addCombatLog(`SUCCESS: Target ${this.id} eliminated`, "success");
                    }
                }, 2000);
            }

            takeDamage(amount) {
                this.health -= amount;
                this.health = Math.max(0, this.health);
                
                // Play hit reaction
                this.playAnimation('RecieveHit', 0.1);
                
                // Chance to evade
                if (this.health > 0 && Math.random() < CONFIG.ENEMY.EVADE_CHANCE) {
                    this.setState(CONFIG.ENEMY.STATES.EVADE);
                }
                
                return this.health <= 0;
            }
        }

        // ============================================
        // COMBAT SYSTEM
        // ============================================
        function spawnEnemy() {
            if (enemies.length >= 5) {
                addCombatLog("SYSTEM: Maximum active enemies (5)", "alert");
                return;
            }

            const loader = new THREE.GLTFLoader();
            loader.load('Character Animated.glb', (gltf) => {
                const enemy = gltf.scene;
                
                // Scale character
                const box = new THREE.Box3().setFromObject(enemy);
                const size = box.getSize(new THREE.Vector3());
                const scale = 4 / size.y;
                enemy.scale.set(scale, scale, scale);
                
                // Position enemy in front of player
                const spawnDistance = 10;
                const angle = Math.random() * Math.PI * 2;
                enemy.position.set(
                    Math.cos(angle) * spawnDistance,
                    0,
                    Math.sin(angle) * spawnDistance
                );
                
                // Make enemy visually distinct (red tint)
                enemy.traverse((node) => {
                    if (node.isMesh && node.material) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                        // Clone material to avoid affecting other instances
                        node.material = node.material.clone();
                        // Enemy gets red tint
                        node.material.color.set(0xff5555);
                        // Make enemy slightly emissive for visibility
                        node.material.emissive = new THREE.Color(0x331111);
                        node.material.emissiveIntensity = 0.2;
                    }
                });
                
                scene.add(enemy);
                
                // Setup animation mixer
                const mixer = new THREE.AnimationMixer(enemy);
                const actions = {};
                gltf.animations.forEach((clip) => {
                    const action = mixer.clipAction(clip);
                    actions[clip.name] = action;
                    action.clampWhenFinished = true;
                });
                
                // Create AI
                const ai = new EnemyAI(enemy, mixer, actions);
                enemies.push({ object: enemy, mixer, ai });
                
                updateEnemyCounter();
                updateEnemyHealthDisplay(ai);
                addCombatLog(`SYSTEM: Enemy spawned (ID: ${ai.id})`, "alert");
            });
        }

        function playerAttack(type) {
            if (!player.object || player.health <= 0) return;
            
            const now = Date.now();
            if (now - player.lastAttack < CONFIG.PLAYER.ATTACK_COOLDOWN) {
                addCombatLog("SYSTEM: Attack cooldown active", "system");
                return;
            }
            
            player.lastAttack = now;
            
            // Play attack animation
            playPlayerAnimation(type, 0.1);
            
            // Check for hits
            setTimeout(() => {
                let hitCount = 0;
                
                enemies.forEach(enemyData => {
                    if (enemyData.ai.state === CONFIG.ENEMY.STATES.DEAD) return;
                    
                    const distance = player.object.position.distanceTo(enemyData.object.position);
                    if (distance <= CONFIG.PLAYER.ATTACK_RANGE) {
                        const damage = CONFIG.PLAYER.ATTACK_DAMAGE[type === 'Punch' ? 'PUNCH' : 'DAGGER'];
                        const isDead = enemyData.ai.takeDamage(damage);
                        
                        if (isDead) {
                            addCombatLog(`COMBAT: Target ${enemyData.ai.id} destroyed!`, "success");
                        } else {
                            addCombatLog(`COMBAT: Hit target ${enemyData.ai.id} (-${damage} HP)`, "damage");
                        }
                        
                        updateEnemyHealthDisplay(enemyData.ai);
                        hitCount++;
                    }
                });
                
                if (hitCount === 0) {
                    addCombatLog("COMBAT: Attack missed", "system");
                }
            }, 200);
        }

        function evade() {
            if (!player.object || player.health <= 0) return;
            
            playPlayerAnimation('Roll', 0.1);
            addCombatLog("SYSTEM: Evasive maneuver executed", "system");
            
            // Move backward during roll
            setTimeout(() => {
                if (player.object) {
                    player.object.translateZ(-3);
                }
            }, 300);
        }

        // ============================================
        // UI UPDATES
        // ============================================
        function updateHealthBar(elementId, current, max) {
            const element = document.getElementById(elementId);
            if (element) {
                const percent = (current / max) * 100;
                element.style.width = `${percent}%`;
                
                // Color change based on health
                if (percent < 30) {
                    element.style.background = 'linear-gradient(90deg, #ff3300, #cc0000)';
                } else if (percent < 60) {
                    element.style.background = 'linear-gradient(90deg, #ffff00, #ff9900)';
                } else {
                    element.style.background = 'linear-gradient(90deg, #00ff9d, #00cc66)';
                }
            }
        }

        function updateEnemyHealthDisplay(enemyAI) {
            if (enemyAI.health <= 0) return;
            
            document.getElementById('enemy-label').style.display = 'block';
            document.getElementById('enemy-health-bar').style.display = 'block';
            updateHealthBar('enemy-health', enemyAI.health, enemyAI.maxHealth);
        }

        function updateEnemyCounter() {
            document.getElementById('enemy-counter').textContent = `TARGETS: ${enemies.length}`;
        }

        function addCombatLog(message, type = 'system') {
            const log = document.getElementById('combat-log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString([], {hour12: false})}] ${message}`;
            
            log.appendChild(entry);
            
            // Auto-scroll and limit entries
            log.scrollTop = log.scrollHeight;
            while (log.children.length > 10) {
                log.removeChild(log.firstChild);
            }
        }

        function showHitEffect() {
            const effect = document.getElementById('hit-effect');
            effect.classList.add('active');
            setTimeout(() => effect.classList.remove('active'), 300);
        }

        // ============================================
        // GAME CONTROLS
        // ============================================
        function startMove(type) {
            if (player.health <= 0) return;
            
            player.moveSpeed = CONFIG.PLAYER.MOVE_SPEED[type.toUpperCase()];
            playPlayerAnimation(type === 'Run' ? 'Run' : 'Walk');
        }

        function stopMove() {
            player.moveSpeed = 0;
            if (player.health > 0) {
                playPlayerAnimation('Idle');
            }
        }

        function startTurn(direction) {
            if (player.health <= 0) return;
            
            player.turnSpeed = direction === 'Left' ? CONFIG.PLAYER.TURN_SPEED : -CONFIG.PLAYER.TURN_SPEED;
        }

        function stopTurn() {
            player.turnSpeed = 0;
        }

        function gameOver() {
            playPlayerAnimation('Death');
            addCombatLog("SYSTEM: CRITICAL DAMAGE - OPERATOR DOWN", "damage");
            
            // Disable controls
            player.moveSpeed = 0;
            player.turnSpeed = 0;
            
            // Show game over message
            setTimeout(() => {
                addCombatLog("SYSTEM: MISSION FAILED", "damage");
            }, 1000);
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            // Update player
            if (player.object) {
                // Movement
                if (player.moveSpeed !== 0) {
                    player.object.translateZ(player.moveSpeed);
                    updateInfiniteFloor();
                }
                
                // Rotation
                if (player.turnSpeed !== 0) {
                    player.object.rotation.y += player.turnSpeed;
                }
                
                // Update animation mixer
                if (player.mixer) {
                    player.mixer.update(delta);
                }
                
                // Camera follow
                const cameraOffset = new THREE.Vector3(0, 8, 15);
                cameraOffset.applyQuaternion(player.object.quaternion);
                camera.position.copy(player.object.position).add(cameraOffset);
                camera.lookAt(player.object.position);
            }
            
            // Update enemies
            enemies.forEach(enemyData => {
                if (enemyData.mixer) {
                    enemyData.mixer.update(delta);
                }
                if (enemyData.ai) {
                    enemyData.ai.update(delta);
                }
            });
            
            // Update stats
            updateStats(delta);
            
            // Render
            renderer.render(scene, camera);
        }

        function updateStats(delta) {
            const stats = document.getElementById('stats');
            if (stats) {
                stats.innerHTML = `
                    FPS: ${Math.round(1/delta)}<br>
                    Enemies: ${enemies.length}<br>
                    Tiles: ${floorTiles.length}
                `;
            }
        }

        // ============================================
        // EVENT HANDLERS
        // ============================================
        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Orientation check
            function checkOrientation() {
                const guard = document.getElementById('landscape-guard');
                const isPortrait = window.innerHeight > window.innerWidth;
                guard.classList.toggle('visible', isPortrait);
            }
            
            window.addEventListener('resize', checkOrientation);
            window.addEventListener('orientationchange', checkOrientation);
            checkOrientation();
            
            // Prevent context menu on long press
            document.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Prevent zoom on double tap
            let lastTouchEnd = 0;
            document.addEventListener('touchend', (e) => {
                const now = Date.now();
                if (now - lastTouchEnd < 300) {
                    e.preventDefault();
                }
                lastTouchEnd = now;
            }, false);
        }

        // ============================================
        // START GAME
        // ============================================
        window.addEventListener('load', init);
    </script>
</body>
</html>
