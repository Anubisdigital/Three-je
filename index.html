<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mech-Command: Anubis Digital</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #050505; 
            overflow: hidden; 
            font-family: 'Courier New', monospace; 
            color: #00ff64;
            user-select: none;
        }

        /* Landscape Orientation Check */
        #rotate-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100; display: none;
            flex-direction: column; justify-content: center; align-items: center;
            color: #00ff64;
        }
        @media screen and (orientation: portrait) { #rotate-screen { display: flex; } }

        #canvas-container { 
            position: absolute; 
            top: 0; 
            width: 100%; 
            height: 100%; 
        }

        /* Health Bars */
        .health-container {
            position: absolute;
            top: 50px;
            width: 100%;
            padding: 0 20px;
            z-index: 10;
        }

        .health-bar {
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ff64;
            border-radius: 3px;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0040, #ff3300);
            width: 100%;
            transition: width 0.3s;
        }

        .health-label {
            color: #00ff64;
            font-size: 12px;
            margin-bottom: 5px;
            text-shadow: 0 0 5px #00ff64;
        }

        /* Tactical UI */
        .game-interface {
            position: absolute; 
            bottom: 20px; 
            width: 100%;
            display: flex; 
            justify-content: space-between; 
            align-items: flex-end;
            padding: 0 20px; 
            z-index: 10;
        }

        .movement-zone { 
            display: flex; 
            flex-direction: column;
            gap: 10px; 
        }

        .combat-zone {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .action-zone { 
            display: flex; 
            flex-direction: column; 
            gap: 10px; 
            align-items: flex-end; 
        }

        .control-group {
            display: flex;
            gap: 10px;
        }

        select, button {
            background: rgba(0, 255, 100, 0.1); 
            border: 2px solid #00ff64;
            color: #00ff64; 
            border-radius: 5px; 
            padding: 12px;
            font-size: 12px; 
            font-weight: bold; 
            backdrop-filter: blur(10px);
            cursor: pointer;
            min-width: 100px;
            text-align: center;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        select { 
            width: 180px; 
            appearance: none; 
            text-align: center; 
        }

        button:hover { 
            background: rgba(0, 255, 100, 0.3); 
        }

        button:active { 
            background: #00ff64; 
            color: #000; 
            transform: scale(0.95);
        }

        button.combat-btn {
            background: rgba(255, 0, 64, 0.2);
            border-color: #ff0040;
            color: #ff0040;
        }

        button.combat-btn:active {
            background: #ff0040;
            color: #000;
        }

        #hud { 
            position: absolute; 
            top: 15px; 
            left: 15px; 
            font-size: 11px; 
            pointer-events: none; 
            text-shadow: 0 0 10px #00ff64;
        }

        #debug {
            position: absolute;
            top: 100px;
            left: 15px;
            color: #00ff64;
            font-size: 10px;
            opacity: 0.7;
        }

        /* Combat Effects */
        .damage-popup {
            position: absolute;
            color: #ff3300;
            font-weight: bold;
            font-size: 20px;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            text-shadow: 0 0 10px #ff3300;
            z-index: 20;
        }

        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }

        .screen-shake {
            animation: shake 0.3s ease-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
    </style>
</head>
<body>

    <div id="rotate-screen">
        <h1>ACCESS DENIED</h1>
        <p>ROTATE DEVICE TO LANDSCAPE FOR PILOT VIEW</p>
    </div>

    <div id="hud">
        SYSTEM_READY // GRID_LOCK: INFINITE<br>
        SECTOR: UNKNOWN // COMBAT: <span id="combat-status">INACTIVE</span><br>
        ENEMIES: <span id="enemy-count">0</span>
    </div>

    <div class="health-container">
        <div class="health-label">PLAYER HEALTH</div>
        <div class="health-bar">
            <div id="player-health" class="health-fill" style="width: 100%"></div>
        </div>
        <div class="health-label">ENEMY HEALTH</div>
        <div class="health-bar" id="enemy-health-bar" style="display: none;">
            <div id="enemy-health" class="health-fill" style="width: 100%"></div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <div id="debug"></div>

    <div class="game-interface">
        <div class="movement-zone">
            <div class="control-group">
                <button onpointerdown="startMove('Walk')" onpointerup="stopMove()">WALK</button>
                <button onpointerdown="startMove('Run')" onpointerup="stopMove()">RUN</button>
            </div>
            <div class="control-group">
                <button onpointerdown="startTurn('Left')" onpointerup="stopTurn()">TURN LEFT</button>
                <button onpointerdown="startTurn('Right')" onpointerup="stopTurn()">TURN RIGHT</button>
            </div>
        </div>

        <div class="combat-zone">
            <button class="combat-btn" onclick="spawnEnemy()">SPAWN ENEMY</button>
            <button class="combat-btn" onclick="attack('Punch')">PUNCH ATTACK</button>
            <button class="combat-btn" onclick="attack('Kick')">KICK ATTACK</button>
        </div>

        <div class="action-zone">
            <select id="anim-select" onchange="playAction(this.value)">
                <option value="">-- SELECT MANEUVER --</option>
                <option value="Attacking_Idle">Combat Stance</option>
                <option value="Dagger_Attack">Dagger Strike</option>
                <option value="Dagger_Attack2">Double Strike</option>
                <option value="Punch">Power Punch</option>
                <option value="Kick">Roundhouse Kick</option>
                <option value="Roll">Tactical Roll</option>
                <option value="RecieveHit">Impact Reaction</option>
                <option value="Death">Self-Destruct</option>
                <option value="PickUp">Interact</option>
            </select>
            <button onclick="playAction('Roll')">EVASIVE_ROLL</button>
            <button onclick="resetGame()">RESET GAME</button>
        </div>
    </div>

    <script>
        // Game State
        let scene, camera, renderer, character, mixer, clock;
        let actions = {};
        let currentAction, moveSpeed = 0, turnSpeed = 0;
        let enemies = [];
        let playerHealth = 100;
        let enemyHealth = 50;
        let currentEnemy = null;
        let isInCombat = false;
        let infiniteWorld = true;
        let lastAttackTime = 0;
        const ATTACK_COOLDOWN = 1000; // 1 second

        // Infinite world parameters
        const CHUNK_SIZE = 50;
        const CHUNK_LOAD_DISTANCE = 100;
        let loadedChunks = new Set();
        let characterChunkX = 0;
        let characterChunkZ = 0;

        function init() {
            scene = new THREE.Scene();
            clock = new THREE.Clock();
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 6, 12);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Enhanced lighting
            scene.add(new THREE.AmbientLight(0x404040, 0.6));
            
            const directionalLight = new THREE.DirectionalLight(0x00ff64, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            // Create infinite floor
            createInfiniteFloor();

            const loader = new THREE.GLTFLoader();
            loader.load('Character Animated.glb', (gltf) => {
                character = gltf.scene;
                
                // Auto-Scale
                const box = new THREE.Box3().setFromObject(character);
                const size = box.getSize(new THREE.Vector3());
                character.scale.set(4/size.y, 4/size.y, 4/size.y);
                
                // Enable shadows
                character.traverse((node) => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
                
                scene.add(character);

                mixer = new THREE.AnimationMixer(character);
                gltf.animations.forEach((clip) => {
                    actions[clip.name] = mixer.clipAction(clip);
                    actions[clip.name].clampWhenFinished = true;
                });

                playAction('Idle');
            });

            // Start game loop
            animate();
        }

        function createInfiniteFloor() {
            // Create initial floor chunk
            for (let x = -CHUNK_SIZE; x <= CHUNK_SIZE; x += CHUNK_SIZE) {
                for (let z = -CHUNK_SIZE; z <= CHUNK_SIZE; z += CHUNK_SIZE) {
                    createFloorChunk(x, 0, z);
                }
            }
        }

        function createFloorChunk(x, y, z) {
            const chunkKey = `${Math.floor(x/CHUNK_SIZE)},${Math.floor(z/CHUNK_SIZE)}`;
            if (loadedChunks.has(chunkKey)) return;
            
            loadedChunks.add(chunkKey);
            
            const grid = new THREE.GridHelper(CHUNK_SIZE, CHUNK_SIZE/2, 0x00ff64, 0x111111);
            grid.position.set(x, y, z);
            scene.add(grid);
            
            // Add ground plane for shadows
            const groundGeometry = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x111111,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.set(x, -0.1, z);
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function updateInfiniteWorld() {
            if (!character || !infiniteWorld) return;
            
            const charPos = character.position;
            const chunkX = Math.floor(charPos.x / CHUNK_SIZE) * CHUNK_SIZE;
            const chunkZ = Math.floor(charPos.z / CHUNK_SIZE) * CHUNK_SIZE;
            
            if (chunkX !== characterChunkX || chunkZ !== characterChunkZ) {
                characterChunkX = chunkX;
                characterChunkZ = chunkZ;
                
                // Load chunks around player
                for (let x = chunkX - CHUNK_LOAD_DISTANCE; x <= chunkX + CHUNK_LOAD_DISTANCE; x += CHUNK_SIZE) {
                    for (let z = chunkZ - CHUNK_LOAD_DISTANCE; z <= chunkZ + CHUNK_LOAD_DISTANCE; z += CHUNK_SIZE) {
                        createFloorChunk(x, 0, z);
                    }
                }
            }
        }

        function spawnEnemy() {
            if (enemies.length >= 3) {
                showDamagePopup("MAX ENEMIES REACHED", character.position);
                return;
            }

            const loader = new THREE.GLTFLoader();
            loader.load('Character Animated.glb', (gltf) => {
                const enemy = gltf.scene;
                
                // Scale enemy
                const box = new THREE.Box3().setFromObject(enemy);
                const size = box.getSize(new THREE.Vector3());
                enemy.scale.set(4/size.y, 4/size.y, 4/size.y);
                
                // Position enemy in front of player
                const offset = new THREE.Vector3(0, 0, 5);
                if (character) {
                    offset.applyQuaternion(character.quaternion);
                    enemy.position.copy(character.position).add(offset);
                } else {
                    enemy.position.set(0, 0, 5);
                }
                
                // Enable shadows
                enemy.traverse((node) => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                        // Make enemy red for distinction
                        if (node.material) {
                            node.material.color.set(0xff4444);
                        }
                    }
                });
                
                // Add enemy AI components
                enemy.userData = {
                    health: 50,
                    maxHealth: 50,
                    isEnemy: true,
                    attackCooldown: 0,
                    state: 'idle'
                };
                
                enemy.mixer = new THREE.AnimationMixer(enemy);
                gltf.animations.forEach((clip) => {
                    enemy.mixer.clipAction(clip);
                });
                
                enemies.push(enemy);
                scene.add(enemy);
                
                updateEnemyCount();
                showDamagePopup("ENEMY SPAWNED", enemy.position);
                
                if (!currentEnemy) {
                    currentEnemy = enemy;
                    updateEnemyHealthBar();
                }
            });
        }

        function attack(type) {
            if (!currentEnemy) {
                showDamagePopup("NO TARGET", character.position);
                return;
            }
            
            const now = Date.now();
            if (now - lastAttackTime < ATTACK_COOLDOWN) {
                showDamagePopup("COOLDOWN", character.position);
                return;
            }
            
            lastAttackTime = now;
            
            // Play attack animation
            playAction(type);
            
            // Check if enemy is in range
            const distance = character.position.distanceTo(currentEnemy.position);
            if (distance < 5) {
                // Calculate damage
                const damage = type === 'Kick' ? 20 : 15;
                currentEnemy.userData.health -= damage;
                currentEnemy.userData.health = Math.max(0, currentEnemy.userData.health);
                
                // Show damage popup
                showDamagePopup(`-${damage}`, currentEnemy.position);
                
                // Update health bar
                updateEnemyHealthBar();
                
                // Screen shake effect
                document.getElementById('canvas-container').classList.add('screen-shake');
                setTimeout(() => {
                    document.getElementById('canvas-container').classList.remove('screen-shake');
                }, 300);
                
                // Enemy reaction
                if (currentEnemy.userData.health <= 0) {
                    enemyDefeated(currentEnemy);
                } else {
                    // Enemy counter-attack
                    setTimeout(() => enemyAttack(currentEnemy), 500);
                }
                
                updateHUD();
            } else {
                showDamagePopup("OUT OF RANGE", character.position);
            }
        }

        function enemyAttack(enemy) {
            if (enemy.userData.health <= 0) return;
            
            // Enemy attacks player
            const distance = character.position.distanceTo(enemy.position);
            if (distance < 5) {
                playerHealth -= 10;
                playerHealth = Math.max(0, playerHealth);
                
                showDamagePopup("-10", character.position);
                updatePlayerHealthBar();
                
                if (playerHealth <= 0) {
                    gameOver();
                }
            }
        }

        function enemyDefeated(enemy) {
            showDamagePopup("ENEMY DEFEATED", enemy.position);
            
            // Play death animation
            const deathAction = enemy.mixer.clipAction(enemy.mixer._actions.find(a => a._clip.name.includes('Death')));
            if (deathAction) {
                deathAction.reset().play();
            }
            
            // Remove enemy after delay
            setTimeout(() => {
                const index = enemies.indexOf(enemy);
                if (index > -1) {
                    enemies.splice(index, 1);
                    scene.remove(enemy);
                    updateEnemyCount();
                    
                    if (enemies.length > 0) {
                        currentEnemy = enemies[0];
                        updateEnemyHealthBar();
                    } else {
                        currentEnemy = null;
                        document.getElementById('enemy-health-bar').style.display = 'none';
                    }
                }
            }, 2000);
        }

        function gameOver() {
            playAction('Death');
            showDamagePopup("GAME OVER", character.position);
            document.getElementById('combat-status').textContent = "DEFEATED";
            
            // Disable controls
            moveSpeed = 0;
            turnSpeed = 0;
        }

        function showDamagePopup(text, position) {
            const popup = document.createElement('div');
            popup.className = 'damage-popup';
            popup.textContent = text;
            
            // Convert 3D position to screen position
            const vector = position.clone();
            vector.project(camera);
            
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
            
            popup.style.left = x + 'px';
            popup.style.top = y + 'px';
            
            document.body.appendChild(popup);
            
            setTimeout(() => {
                document.body.removeChild(popup);
            }, 1000);
        }

        function updatePlayerHealthBar() {
            const percent = (playerHealth / 100) * 100;
            document.getElementById('player-health').style.width = percent + '%';
        }

        function updateEnemyHealthBar() {
            if (!currentEnemy) return;
            
            const percent = (currentEnemy.userData.health / currentEnemy.userData.maxHealth) * 100;
            document.getElementById('enemy-health').style.width = percent + '%';
            document.getElementById('enemy-health-bar').style.display = 'block';
        }

        function updateEnemyCount() {
            document.getElementById('enemy-count').textContent = enemies.length;
        }

        function updateHUD() {
            document.getElementById('combat-status').textContent = isInCombat ? "ENGAGED" : "INACTIVE";
        }

        function playAction(name) {
            if (!name) return;
            const key = Object.keys(actions).find(k => k.toLowerCase() === name.toLowerCase());
            if (actions[key]) {
                if (currentAction) currentAction.fadeOut(0.2);
                currentAction = actions[key];
                
                if (['Punch', 'Kick', 'Dagger_Attack', 'Roll', 'Death', 'PickUp'].some(s => name.includes(s))) {
                    currentAction.setLoop(THREE.LoopOnce);
                    currentAction.clampWhenFinished = true;
                    currentAction.reset().fadeIn(0.2).play();
                    
                    // Return to idle after combat move
                    if (['Punch', 'Kick', 'Dagger_Attack'].some(s => name.includes(s))) {
                        setTimeout(() => {
                            if (moveSpeed === 0) playAction('Idle');
                        }, 500);
                    }
                } else {
                    currentAction.setLoop(THREE.LoopRepeat);
                    currentAction.reset().fadeIn(0.2).play();
                }
            }
        }

        function startMove(type) {
            if (playerHealth <= 0) return;
            
            if (type === 'Walk') {
                moveSpeed = 0.06;
                playAction('Walk');
            } else if (type === 'Run') {
                moveSpeed = 0.15;
                playAction('Run');
            }
        }

        function stopMove() {
            moveSpeed = 0;
            if (playerHealth > 0) {
                playAction('Idle');
            }
        }

        function startTurn(direction) {
            if (playerHealth <= 0) return;
            
            turnSpeed = direction === 'Left' ? 0.02 : -0.02;
        }

        function stopTurn() {
            turnSpeed = 0;
        }

        function resetGame() {
            // Reset player
            playerHealth = 100;
            updatePlayerHealthBar();
            playAction('Idle');
            
            // Remove all enemies
            enemies.forEach(enemy => scene.remove(enemy));
            enemies = [];
            currentEnemy = null;
            
            // Reset UI
            document.getElementById('enemy-health-bar').style.display = 'none';
            updateEnemyCount();
            document.getElementById('combat-status').textContent = "INACTIVE";
            
            // Reset position
            if (character) {
                character.position.set(0, 0, 0);
                character.rotation.set(0, 0, 0);
            }
        }

        function updateEnemies(delta) {
            enemies.forEach(enemy => {
                if (enemy.mixer) enemy.mixer.update(delta);
                
                // Simple AI: Move toward player if not too close
                if (enemy.userData.health > 0 && character) {
                    const distance = enemy.position.distanceTo(character.position);
                    
                    if (distance > 3 && distance < 20) {
                        // Move toward player
                        const direction = new THREE.Vector3()
                            .subVectors(character.position, enemy.position)
                            .normalize()
                            .multiplyScalar(0.03);
                        
                        enemy.position.add(direction);
                        enemy.lookAt(character.position);
                    }
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            if (mixer) mixer.update(delta);
            updateEnemies(delta);

            if (character && moveSpeed !== 0) {
                character.translateZ(moveSpeed);
                
                // Update infinite world
                updateInfiniteWorld();
            }
            
            if (character && turnSpeed !== 0) {
                character.rotation.y += turnSpeed;
            }

            // Update camera to follow character with smooth rotation
            if (character) {
                const cameraOffset = new THREE.Vector3(0, 6, 12);
                cameraOffset.applyQuaternion(character.quaternion);
                camera.position.copy(character.position).add(cameraOffset);
                camera.lookAt(character.position);
            }

            renderer.render(scene, camera);
            
            // Update debug info
            if (character) {
                document.getElementById('debug').innerHTML = 
                    `POS: ${character.position.x.toFixed(1)}, ${character.position.z.toFixed(1)}<br>` +
                    `CHUNK: ${characterChunkX}, ${characterChunkZ}`;
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Handle fullscreen for better mobile experience
        document.addEventListener('dblclick', () => {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                document.documentElement.requestFullscreen();
            }
        });

        init();
    </script>
</body>
</html>
